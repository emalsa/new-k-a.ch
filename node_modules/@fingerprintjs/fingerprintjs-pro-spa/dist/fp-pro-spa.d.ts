/**
 * FingerprintJS Pro SPA v0.6.0 - Copyright (c) FingerprintJS, Inc, 2022 (https://fingerprint.com)
 * Licensed under the MIT (http://www.opensource.org/licenses/mit-license.php) license.
 */

import * as FingerprintJS from '@fingerprintjs/fingerprintjs-pro';
import { GetOptions } from '@fingerprintjs/fingerprintjs-pro';
export { Agent, ExtendedGetResult, GetOptions, GetResult, LoadOptions } from '@fingerprintjs/fingerprintjs-pro';

declare type VisitorData<TExtended extends boolean = false> = TExtended extends false ? FingerprintJS.GetResult : FingerprintJS.ExtendedGetResult;
declare enum CacheLocation {
    Memory = "memory",
    LocalStorage = "localstorage",
    SessionStorage = "sessionstorage",
    NoCache = "nocache"
}
interface FpjsClientOptions {
    /**
     * Options for the FingerprintJS JS Agent load() method.
     */
    loadOptions: FingerprintJS.LoadOptions;
    /**
     * Defines which built-in cache mechanism the client should use.
     */
    cacheLocation?: CacheLocation;
    /**
     * Custom cache implementation. Takes precedence over the `cacheLocation` property.
     */
    cache?: ICache;
    /**
     * Duration in seconds for which data is stored in cache. Cannot exceed 86_400 (24h) because caching data
     * for longer than 24 hours can negatively affect identification accuracy.
     */
    cacheTimeInSeconds?: number;
    /**
     * Custom prefix for localStorage and sessionStorage cache keys. Will be ignored if `cache` is provided.
     */
    cachePrefix?: string;
}

declare type CacheEntry<TExtended extends boolean = false> = VisitorData<TExtended>;
declare type Cacheable<TExtended extends boolean = false> = WrappedCacheEntry<TExtended>;
declare type WrappedCacheEntry<TExtended extends boolean = false> = {
    body: CacheEntry<TExtended>;
    expiresAt: number;
};
declare class CacheKey<TExtended extends boolean> {
    tag: unknown;
    linkedId: string | null;
    extendedResult: boolean | NonNullable<TExtended>;
    constructor(options: GetOptions<TExtended>);
    /**
     * Converts this `CacheKey` instance into a string for use in a cache
     * @returns A string representation of the key
     */
    toKey(): string;
}
declare type MaybePromise<T> = Promise<T> | T;
interface ICache {
    set<T = WrappedCacheEntry>(key: string, entry: T): MaybePromise<void>;
    get<T = WrappedCacheEntry>(key: string): MaybePromise<T | undefined>;
    remove(key: string): MaybePromise<void>;
    allKeys(): MaybePromise<string[]>;
}

/**
 * Implementation of caching that uses local storage
 * */
declare class LocalStorageCache implements ICache {
    prefix: string;
    constructor(prefix?: string);
    set<T = Cacheable>(key: string, entry: T): void;
    get<T = Cacheable>(key: string): T | undefined;
    remove(key: string): void;
    allKeys(): string[];
}

/**
 * Implementation of caching that uses session storage
 * */
declare class SessionStorageCache implements ICache {
    prefix: string;
    constructor(prefix?: string);
    /**
     * It takes a key and an entry, and sets the entry in the session storage with the key
     * @param {string} key - The key to store the entry under.
     * @param {Cacheable} entry - The value to be stored in the cache.
     */
    set<T = Cacheable>(key: string, entry: T): void;
    /**
     * It gets the value of the key from the session storage, parses it as JSON, and returns it
     * @param {string} key - The key to store the data under.
     * @returns The value of the key in the sessionStorage.
     */
    get<T = Cacheable>(key: string): T | undefined;
    /**
     * It removes the item from session storage with the given key
     * @param {string} key - The key to store the value under.
     */
    remove(key: string): void;
    /**
     * It returns an array of all the keys in the session storage that start with the prefix
     * @returns An array of all the keys in the sessionStorage that start with the prefix.
     */
    allKeys(): string[];
}

/**
 * Implementation of caching that uses in-memory storage
 * */
declare class InMemoryCache {
    enclosedCache: ICache;
}

/**
 * Implementation of stub cache that is used when cache is disabled by user
 * */
declare class CacheStub implements ICache {
    set(): void;
    get(): undefined;
    remove(): void;
    allKeys(): never[];
}

/**
 * FingerprintJS SDK for Single Page Applications
 */
declare class FpjsClient {
    private options;
    private cacheManager;
    private loadOptions;
    private agent;
    private agentPromise;
    readonly cacheLocation?: CacheLocation;
    private inFlightRequests;
    constructor(options: FpjsClientOptions);
    /**
     * Loads FPJS JS agent with certain settings and stores the instance in memory
     * [https://dev.fingerprint.com/docs/js-agent#agent-initialization]
     */
    init(): Promise<FingerprintJS.Agent>;
    /**
     * Returns visitor identification data based on the request options
     * [https://dev.fingerprint.com/docs/js-agent#visitor-identification]
     *
     * @param options
     * @param ignoreCache if set to true a request to the API will be made even if the data is present in cache
     */
    getVisitorData<TExtended extends boolean>(options?: GetOptions<TExtended>, ignoreCache?: boolean): Promise<VisitorData<TExtended>>;
    /**
     * Clears visitor data from cache regardless of the cache implementation
     */
    clearCache(): Promise<void>;
    /**
     * Makes a CacheKey object from GetOptions
     */
    static makeCacheKey<TExtended extends boolean>(options: GetOptions<TExtended>): CacheKey<TExtended>;
    private _identify;
}

export { CacheLocation, CacheStub, Cacheable, FpjsClient, FpjsClientOptions, ICache, InMemoryCache, LocalStorageCache, SessionStorageCache, VisitorData };
