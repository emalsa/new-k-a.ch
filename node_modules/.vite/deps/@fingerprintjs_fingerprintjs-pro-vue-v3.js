import {
  inject,
  onMounted,
  ref
} from "./chunk-K2Y2XOQ5.js";
import "./chunk-RSJERJUL.js";

// node_modules/tslib/tslib.es6.js
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __rest(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l2 = from.length, ar; i < l2; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}

// node_modules/@fingerprintjs/fingerprintjs-pro/dist/fp.esm.min.js
function r(e, t) {
  return function(e2, t2) {
    return Object.prototype.hasOwnProperty.call(e2, t2);
  }(e, t) ? e[t] : void 0;
}
function o(e) {
  for (var t = "", n = 0; n < e.length; ++n)
    if (n > 0) {
      var r2 = e[n].toLowerCase();
      r2 !== e[n] ? t += " ".concat(r2) : t += e[n];
    } else
      t += e[n].toUpperCase();
  return t;
}
var s = "Blocked by CSP";
var f = o("WrongRegion");
var l = o("SubscriptionNotActive");
var d = o("UnsupportedVersion");
var _ = o("InstallationMethodRestricted");
var p = o("HostnameRestricted");
var O = o("IntegrationFailed");
var v = "API key required";
var U = "3.8.2";
var L = "9319";
function g(t, n) {
  var r2 = [];
  return function(t2, n2) {
    var r3 = 5, o2 = (E = t2, f2 = __spreadArray([], E, true), { current: function() {
      return f2[0];
    }, postpone: function() {
      var e = f2.shift();
      void 0 !== e && f2.push(e);
    }, exclude: function() {
      f2.shift();
    } }), i = (R = 100, a = 3e3, c = 0, function() {
      return Math.random() * Math.min(a, R * Math.pow(2, c++));
    }), u = o2.current();
    var R, a, c;
    var E, f2;
    if (void 0 === u)
      return Promise.reject(new TypeError("The list of script URL patterns is empty"));
    var l2 = function(e, t3) {
      return n2(e).catch(function(e2) {
        if (t3 + 1 >= r3)
          throw e2;
        !function(e3) {
          if (!(e3 instanceof Error))
            return false;
          var t4 = e3.message;
          return t4 === s || t4 === L;
        }(e2) ? o2.postpone() : o2.exclude();
        var n3, u2 = o2.current();
        if (void 0 === u2)
          throw e2;
        return (n3 = i(), new Promise(function(e3) {
          return setTimeout(e3, n3);
        })).then(function() {
          return l2(u2, t3 + 1);
        });
      });
    };
    return l2(u, 0);
  }(t, function(e) {
    var t2 = new Date(), o2 = function() {
      return r2.push({ url: e, startedAt: t2, finishedAt: new Date() });
    }, i = n(e);
    return i.then(o2, o2), i;
  }).then(function(e) {
    return [e, { attempts: r2 }];
  });
}
var C = "https://fpnpmcdn.net/v<version>/<apiKey>/loader_v<loaderVersion>.js";
var K = "Failed to load the JS script of the agent";
function M(e) {
  var o2;
  e.scriptUrlPattern;
  var i = e.token, u = e.apiKey, R = void 0 === u ? i : u, a = __rest(e, ["scriptUrlPattern", "token", "apiKey"]), c = null !== (o2 = r(e, "scriptUrlPattern")) && void 0 !== o2 ? o2 : C;
  return Promise.resolve().then(function() {
    if (!R || "string" != typeof R)
      throw new Error(v);
    var e2 = function(e3, t) {
      return (Array.isArray(e3) ? e3 : [e3]).map(function(e4) {
        return function(e5, t2) {
          var n = encodeURIComponent;
          return e5.replace(/<[^<>]+>/g, function(e6) {
            return "<version>" === e6 ? "3" : "<apiKey>" === e6 ? n(t2) : "<loaderVersion>" === e6 ? n(U) : e6;
          });
        }(String(e4), t);
      });
    }(c, R);
    return g(e2, B).catch(k);
  }).then(function(e2) {
    var t = e2[0], r2 = e2[1];
    return t.load(__assign(__assign({}, a), { ldi: r2 }));
  });
}
function B(e) {
  return function(e2, t, n, r2) {
    var o2, i = document, u = "securitypolicyviolation", R = function(t2) {
      var n2 = new URL(e2, location.href), r3 = t2.blockedURI;
      r3 !== n2.href && r3 !== n2.protocol.slice(0, -1) && r3 !== n2.origin || (o2 = t2, a());
    };
    i.addEventListener(u, R);
    var a = function() {
      return i.removeEventListener(u, R);
    };
    return null == r2 || r2.then(a, a), Promise.resolve().then(t).then(function(e3) {
      return a(), e3;
    }, function(e3) {
      return new Promise(function(e4) {
        return setTimeout(e4);
      }).then(function() {
        if (a(), o2)
          return n(o2);
        throw e3;
      });
    });
  }(e, function() {
    return function(e2) {
      return new Promise(function(t, n) {
        var r2 = document.createElement("script"), o2 = function() {
          var e3;
          return null === (e3 = r2.parentNode) || void 0 === e3 ? void 0 : e3.removeChild(r2);
        }, i = document.head || document.getElementsByTagName("head")[0];
        r2.onload = function() {
          o2(), t();
        }, r2.onerror = function() {
          o2(), n(new Error(K));
        }, r2.async = true, r2.src = e2, i.appendChild(r2);
      });
    }(e);
  }, function() {
    throw new Error(s);
  }).then(F);
}
function F() {
  var e = window, t = "__fpjs_p_l_b", n = e[t];
  if (function(e2, t2) {
    var n2, r2 = null === (n2 = Object.getOwnPropertyDescriptor) || void 0 === n2 ? void 0 : n2.call(Object, e2, t2);
    (null == r2 ? void 0 : r2.configurable) ? delete e2[t2] : r2 && !r2.writable || (e2[t2] = void 0);
  }(e, t), "function" != typeof (null == n ? void 0 : n.load))
    throw new Error(L);
  return n;
}
function k(e) {
  throw e instanceof Error && e.message === L ? new Error(K) : e;
}

// node_modules/@fingerprintjs/fingerprintjs-pro-spa/dist/fp-pro-spa.esm.js
var CACHE_KEY_PREFIX = "@fpjs@client@";
var MAX_CACHE_LIFE = 60 * 60 * 24;
var DEFAULT_CACHE_LIFE = 60 * 60;
var DEFAULT_NOW_PROVIDER = () => Date.now();
var CacheKey = class {
  constructor(options) {
    var _a;
    this.tag = options.tag || null;
    this.linkedId = options.linkedId || null;
    this.extendedResult = (_a = options.extendedResult) !== null && _a !== void 0 ? _a : false;
  }
  /**
   * Converts this `CacheKey` instance into a string for use in a cache
   * @returns A string representation of the key
   */
  toKey() {
    return `${JSON.stringify(this.tag)}__${JSON.stringify(this.linkedId)}__${this.extendedResult}`;
  }
};
function getKeyWithPrefix(key, prefix) {
  return `${prefix}__${key}`;
}
function removePrefixFromKey(key, prefix) {
  return key.replace(`${prefix}__`, "");
}
var LocalStorageCache = class {
  constructor(prefix = CACHE_KEY_PREFIX) {
    this.prefix = prefix;
  }
  set(key, entry) {
    window.localStorage.setItem(getKeyWithPrefix(key, this.prefix), JSON.stringify(entry));
  }
  get(key) {
    const json = window.localStorage.getItem(getKeyWithPrefix(key, this.prefix));
    if (!json) {
      return;
    }
    try {
      return JSON.parse(json);
    } catch (e) {
      return;
    }
  }
  remove(key) {
    window.localStorage.removeItem(getKeyWithPrefix(key, this.prefix));
  }
  allKeys() {
    return Object.keys(window.localStorage).filter((key) => key.startsWith(this.prefix)).map((key) => removePrefixFromKey(key, this.prefix));
  }
};
var SessionStorageCache = class {
  constructor(prefix = CACHE_KEY_PREFIX) {
    this.prefix = prefix;
  }
  /**
   * It takes a key and an entry, and sets the entry in the session storage with the key
   * @param {string} key - The key to store the entry under.
   * @param {Cacheable} entry - The value to be stored in the cache.
   */
  set(key, entry) {
    window.sessionStorage.setItem(getKeyWithPrefix(key, this.prefix), JSON.stringify(entry));
  }
  /**
   * It gets the value of the key from the session storage, parses it as JSON, and returns it
   * @param {string} key - The key to store the data under.
   * @returns The value of the key in the sessionStorage.
   */
  get(key) {
    const json = window.sessionStorage.getItem(getKeyWithPrefix(key, this.prefix));
    if (!json) {
      return;
    }
    try {
      return JSON.parse(json);
    } catch (e) {
      return;
    }
  }
  /**
   * It removes the item from session storage with the given key
   * @param {string} key - The key to store the value under.
   */
  remove(key) {
    window.sessionStorage.removeItem(getKeyWithPrefix(key, this.prefix));
  }
  /**
   * It returns an array of all the keys in the session storage that start with the prefix
   * @returns An array of all the keys in the sessionStorage that start with the prefix.
   */
  allKeys() {
    return Object.keys(window.sessionStorage).filter((key) => key.startsWith(this.prefix)).map((key) => removePrefixFromKey(key, this.prefix));
  }
};
var CacheManager = class {
  constructor(cache, cacheTime = DEFAULT_CACHE_LIFE, nowProvider) {
    this.cache = cache;
    this.cacheTime = cacheTime;
    this.nowProvider = nowProvider || DEFAULT_NOW_PROVIDER;
  }
  /**
   * It gets a cache entry from the cache, and if it's expired, it removes it from the cache
   * @param cacheKey - CacheKey<TExtended>
   * @returns A promise that resolves to a cache entry or undefined.
   */
  get(cacheKey) {
    return __awaiter(this, void 0, void 0, function* () {
      const wrappedEntry = yield this.cache.get(cacheKey.toKey());
      if (!wrappedEntry) {
        return;
      }
      const now = yield this.nowProvider();
      const nowSeconds = Math.floor(now / 1e3);
      if (wrappedEntry.expiresAt < nowSeconds) {
        yield this.cache.remove(cacheKey.toKey());
        return;
      }
      return wrappedEntry.body;
    });
  }
  /**
   * It takes a cache key and a cache entry, wraps the cache entry, and then sets the wrapped cache entry in the cache
   * @param cacheKey - CacheKey<TExtended>
   * @param {CacheEntry} entry - The cache entry to be stored.
   */
  set(cacheKey, entry) {
    return __awaiter(this, void 0, void 0, function* () {
      const wrappedEntry = yield this.wrapCacheEntry(entry);
      yield this.cache.set(cacheKey.toKey(), wrappedEntry);
    });
  }
  /**
   * It gets all the keys in the cache, and then removes them all
   */
  clearCache() {
    return __awaiter(this, void 0, void 0, function* () {
      const keys = yield this.cache.allKeys();
      yield Promise.all(keys.map((key) => this.cache.remove(key)));
    });
  }
  wrapCacheEntry(entry) {
    return __awaiter(this, void 0, void 0, function* () {
      const now = yield this.nowProvider();
      const expiresInTime = Math.floor(now / 1e3) + this.cacheTime;
      return {
        body: entry,
        expiresAt: expiresInTime
      };
    });
  }
};
var InMemoryCache = class {
  constructor() {
    this.enclosedCache = function() {
      const cache = {};
      return {
        set(key, entry) {
          cache[key] = entry;
        },
        get(key) {
          const cacheEntry = cache[key];
          if (!cacheEntry) {
            return;
          }
          return cacheEntry;
        },
        remove(key) {
          delete cache[key];
        },
        allKeys() {
          return Object.keys(cache);
        }
      };
    }();
  }
};
var CacheStub = class {
  set() {
  }
  get() {
    return void 0;
  }
  remove() {
  }
  allKeys() {
    return [];
  }
};
var CacheLocation;
(function(CacheLocation2) {
  CacheLocation2["Memory"] = "memory";
  CacheLocation2["LocalStorage"] = "localstorage";
  CacheLocation2["SessionStorage"] = "sessionstorage";
  CacheLocation2["NoCache"] = "nocache";
})(CacheLocation || (CacheLocation = {}));
var version = "0.6.0";
var cacheLocationBuilders = {
  [CacheLocation.Memory]: () => new InMemoryCache().enclosedCache,
  [CacheLocation.LocalStorage]: (prefix) => new LocalStorageCache(prefix),
  [CacheLocation.SessionStorage]: (prefix) => new SessionStorageCache(prefix),
  [CacheLocation.NoCache]: () => new CacheStub()
};
var cacheFactory = (location2) => {
  return cacheLocationBuilders[location2];
};
var FpjsClient = class {
  constructor(options) {
    var _a;
    this.options = options;
    this.inFlightRequests = /* @__PURE__ */ new Map();
    this.agentPromise = null;
    this.agent = {
      get: () => {
        throw new Error("FPJSAgent hasn't loaded yet. Make sure to call the init() method first.");
      }
    };
    this.loadOptions = Object.assign(Object.assign({}, options.loadOptions), { integrationInfo: [...options.loadOptions.integrationInfo || [], `fingerprintjs-pro-spa/${version}`] });
    if (options.cache && options.cacheLocation) {
      console.warn("Both `cache` and `cacheLocation` options have been specified in the FpjsClient configuration; ignoring `cacheLocation` and using `cache`.");
    }
    let cache;
    if (options.cache) {
      cache = options.cache;
    } else {
      this.cacheLocation = options.cacheLocation || CacheLocation.SessionStorage;
      if (!cacheFactory(this.cacheLocation)) {
        throw new Error(`Invalid cache location "${this.cacheLocation}"`);
      }
      cache = cacheFactory(this.cacheLocation)(options.cachePrefix);
    }
    if (options.cacheTimeInSeconds && options.cacheTimeInSeconds > MAX_CACHE_LIFE) {
      throw new Error(`Cache time cannot exceed 86400 seconds (24 hours)`);
    }
    const cacheTime = (_a = options.cacheTimeInSeconds) !== null && _a !== void 0 ? _a : DEFAULT_CACHE_LIFE;
    this.cacheManager = new CacheManager(cache, cacheTime);
  }
  /**
   * Loads FPJS JS agent with certain settings and stores the instance in memory
   * [https://dev.fingerprint.com/docs/js-agent#agent-initialization]
   */
  init() {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.agentPromise) {
        this.agentPromise = M(this.loadOptions).then((agent) => {
          this.agent = agent;
          return agent;
        }).catch((error) => {
          this.agentPromise = null;
          throw error;
        });
      }
      return this.agentPromise;
    });
  }
  /**
   * Returns visitor identification data based on the request options
   * [https://dev.fingerprint.com/docs/js-agent#visitor-identification]
   *
   * @param options
   * @param ignoreCache if set to true a request to the API will be made even if the data is present in cache
   */
  getVisitorData(options = {}, ignoreCache = false) {
    return __awaiter(this, void 0, void 0, function* () {
      const cacheKey = FpjsClient.makeCacheKey(options);
      const key = cacheKey.toKey();
      if (!this.inFlightRequests.has(key)) {
        const promise = this._identify(options, ignoreCache).finally(() => {
          this.inFlightRequests.delete(key);
        });
        this.inFlightRequests.set(key, promise);
      }
      return yield this.inFlightRequests.get(key);
    });
  }
  /**
   * Clears visitor data from cache regardless of the cache implementation
   */
  clearCache() {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.cacheManager.clearCache();
    });
  }
  /**
   * Makes a CacheKey object from GetOptions
   */
  static makeCacheKey(options) {
    return new CacheKey(options);
  }
  _identify(options, ignoreCache = false) {
    return __awaiter(this, void 0, void 0, function* () {
      const key = FpjsClient.makeCacheKey(options);
      if (!ignoreCache) {
        const cacheResult = yield this.cacheManager.get(key);
        if (cacheResult) {
          return cacheResult;
        }
      }
      const agentResult = yield this.agent.get(options);
      yield this.cacheManager.set(key, agentResult);
      return agentResult;
    });
  }
};

// node_modules/@fingerprintjs/fingerprintjs-pro-vue-v3/dist/plugin.esm.js
var version2 = "1.1.1";
var GET_VISITOR_DATA = Symbol("fpjs-getVisitorData");
var CLEAR_CACHE = Symbol("fpjs-clearCache");
var getOptions = (options, packageName, version3) => {
  var _a, _b;
  const clientOptions = Object.assign(Object.assign({}, options), { loadOptions: Object.assign(Object.assign({}, options.loadOptions), { integrationInfo: [...(_b = (_a = options.loadOptions) === null || _a === void 0 ? void 0 : _a.integrationInfo) !== null && _b !== void 0 ? _b : [], `${packageName}/${version3}`] }) });
  return clientOptions;
};
function __rest2(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t[p2[i]] = s2[p2[i]];
    }
  return t;
}
function __awaiter2(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function makeClientMethods(client) {
  const initPromise = client.init();
  const getVisitorData = (agentOptions, ignoreCache) => __awaiter2(this, void 0, void 0, function* () {
    if (typeof window === "undefined") {
      throw new Error("getVisitorData() can only be called in the browser. If you are using nuxt, you should apply our plugin only on client side.");
    }
    yield initPromise;
    return client.getVisitorData(agentOptions, ignoreCache);
  });
  const clearCache = client.clearCache.bind(client);
  return {
    clearCache,
    getVisitorData
  };
}
var fpjsPlugin = {
  install: (app, options) => {
    const client = new FpjsClient(getOptions(options, "fingerprintjs-pro-vue-v3", version2));
    const { getVisitorData, clearCache } = makeClientMethods(client);
    app.provide(GET_VISITOR_DATA, getVisitorData);
    app.provide(CLEAR_CACHE, clearCache);
    app.config.globalProperties.$fpjs = {
      getVisitorData,
      clearCache
    };
  }
};
function setMixinData(dataName, key, value) {
  this.$data[dataName][key] = value;
}
function createMixin(extended) {
  const suffix = extended ? "Extended" : "";
  const dataName = extended ? "visitorDataExtended" : "visitorData";
  const methodName = `$getVisitorData${suffix}`;
  const getVisitorData = function(options) {
    var _a, _b;
    return __awaiter2(this, void 0, void 0, function* () {
      const fpjs = (_a = this.$fpjs) !== null && _a !== void 0 ? _a : (_b = this.$root) === null || _b === void 0 ? void 0 : _b.$fpjs;
      const boundSetData = setMixinData.bind(this);
      const setData = (key, value) => {
        return boundSetData(dataName, key, value);
      };
      if (!fpjs) {
        throw new TypeError("$fpjs is not defined.");
      }
      try {
        setData("isLoading", true);
        setData("data", yield fpjs.getVisitorData(Object.assign(Object.assign({}, options !== null && options !== void 0 ? options : {}), { extendedResult: extended }), options === null || options === void 0 ? void 0 : options.ignoreCache));
      } catch (error) {
        setData("error", error);
      } finally {
        setData("isLoading", false);
      }
    });
  };
  return {
    data() {
      return {
        [dataName]: {
          isLoading: false,
          data: void 0,
          error: void 0
        }
      };
    },
    methods: {
      [methodName]: getVisitorData
    }
  };
}
var fpjsGetVisitorDataMixin = createMixin(false);
var fpjsGetVisitorDataExtendedMixin = createMixin(true);
function useVisitorData(_a = {}, _b) {
  var { ignoreCache: defaultIgnoreCache } = _a, options = __rest2(_a, ["ignoreCache"]);
  var _c = _b === void 0 ? {} : _b, _d = _c.immediate, immediate = _d === void 0 ? true : _d;
  const data = ref();
  const isLoading = ref(false);
  const currentError = ref();
  const getVisitorData = inject(GET_VISITOR_DATA);
  if (!getVisitorData) {
    throw new Error("GET_VISITOR_DATA inject data is missing, perhaps you forgot to install the plugin first?");
  }
  const getData = (getDataOptions) => __awaiter2(this, void 0, void 0, function* () {
    isLoading.value = true;
    const ignoreCache = typeof (getDataOptions === null || getDataOptions === void 0 ? void 0 : getDataOptions.ignoreCache) === "boolean" ? getDataOptions.ignoreCache : defaultIgnoreCache;
    try {
      const result = yield getVisitorData(options, ignoreCache);
      data.value = result;
      currentError.value = void 0;
      return result;
    } catch (error) {
      data.value = void 0;
      if (error instanceof Error) {
        error.message = `${error.name}: ${error.message}`;
        error.name = "FPJSAgentError";
        currentError.value = error;
      }
      return void 0;
    } finally {
      isLoading.value = false;
    }
  });
  onMounted(() => __awaiter2(this, void 0, void 0, function* () {
    if (immediate) {
      yield getData();
    }
  }));
  return {
    getData,
    data,
    isLoading,
    error: currentError
  };
}
export {
  CLEAR_CACHE,
  CacheLocation,
  GET_VISITOR_DATA,
  InMemoryCache,
  LocalStorageCache,
  SessionStorageCache,
  fpjsPlugin as default,
  fpjsGetVisitorDataExtendedMixin,
  fpjsGetVisitorDataMixin,
  fpjsPlugin,
  useVisitorData
};
//# sourceMappingURL=@fingerprintjs_fingerprintjs-pro-vue-v3.js.map
